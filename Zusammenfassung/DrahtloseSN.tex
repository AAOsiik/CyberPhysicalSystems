\documentclass[a4paper]{article}

%%% packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{subcaption}
\usepackage{amsmath,amssymb}
\usepackage{alltt}
\usepackage{natbib} % please use \citep and \citet instead of \cite
\usepackage{tikz}
\usetikzlibrary{positioning,automata}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.arrows}
\usepackage{array}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[export]{adjustbox}
\definecolor{dark-red}{rgb}{0.4,0.15,0.15}
\definecolor{dark-blue}{rgb}{0.15,0.15,0.8}
\definecolor{medium-blue}{rgb}{0,0,0.5}
\hypersetup{
	colorlinks, linkcolor={dark-red},
	citecolor={dark-blue}, urlcolor={medium-blue}
}

\graphicspath{{./figs/}}
\DeclareGraphicsExtensions{.pdf}

\setlength{\parindent}{0mm}

\usepackage{fancyhdr}

%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter
\newcommand{\seminar}{Drahtlose Sensornetze (SS 2019)}
\title{\textbf{Drahtlose Sensornetze: Zusammenfassung}}\let\Title\@title
\newcommand{\sTitle}{Drahtlose Sensornetze}
\newcommand{\AuthorName}{Alexander Osiik}
\author{\AuthorName\\
	\href{mailto:alexander.osiik@student.uni-luebeck.de}{alexander.osiik@student.uni-luebeck.de}\\
	\small \seminar\\
	%    \small Service Robotics Group\\
	\small Institute of Computer Engineering, University of L\"ubeck\\
}\let\Author\@author
\makeatother

\pagestyle{fancy}
\renewcommand{\footrulewidth}{0.4pt}
\lfoot{\seminar}
\cfoot{}
\rfoot{\thepage}
\lhead{\AuthorName}
\rhead{\sTitle}

%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
	\maketitle

\section{Einführung}
\subsection{Sensorknoten?}
\begin{itemize}
	\item sind autonome Miniaturcomputer
	\item können: \begin{itemize}
		\item über Sensoren Wahrnehmen
		\item über Prozessoren verarbeiten
		\item über Funk kommunizieren
	\end{itemize}
\end{itemize}
\subsection{Sensornetz?}
\begin{itemize}
	\item drahtloses Netz aus vielen Sensorknoten
	\item weiträumig, langlebig
	\item erlaubt detaillierte Umweltbeobachtung
\end{itemize}
\subsection{Anwendungen?}
\begin{itemize}
	\item kann als wissenschaftliches Instrument benutzt werden\begin{itemize}
		\item Beobachtung von Tieren, Pflanzen, Umwelphänomene
	\end{itemize}
	\item Industrie\begin{itemize}
		\item Kontrolle von Infrastruktureinrichtungen
		\item Energiemanagement
	\end{itemize}
	\item Gesundheitswesen\begin{itemize}
		\item drahtlose Intensivstationene
		\item medizinische Forschung
	\end{itemize}
	\item Militär / Polizei\begin{itemize}
		\item Erkennung ``feindlicher'' Aktivitäten
	\end{itemize}
\end{itemize}
\subsection{Vorlesung}
Es soll Überblick zu Grundlegenden und einigen weiterführenden	Aspekten drahtloser Sensornetze verschaffen werden.\\
Es ist ein multidiziplinäres Gebiet:
\begin{itemize}
	\item Verteilte Systeme
	\item Informationssysteme
	\item Computer Systeme
	\item Eingebettete Systeme
	\item Ambient Computing
	\item Verteilte Algorithmen
\end{itemize}
\subsection{5G}
Handy verbindet sich mit Base Station Subsystem, dieses verbindet sich mit dem Network Switching System
\begin{itemize}
	\item Enhanced Mobile Breitband: Bisher wurden Frequenzen 1-6Gz genutzt. 5G nutzt nun bis 100GHz
	\item Ultra reliable und geringe Latenzen
	\item höhere Datenraten und mehr Frequenzen bei verringertem Energieverbrauch
\end{itemize}
\subsubsection{Kanalbündelung und Small Cells}
Kanalbündelung ist eine Bündelung der genutzten
Funkfrequenzbereiche eines Netzbetreibers
(Kanäle in einem Frequenzblock). Dies erlaubt es,
Datenrate pro Nutzer zu erhöhen.\\
Small Cell ist die Mobilfunkzelle mit geringer Sendeleistung, dementsprechend kleinem Versorgungsbereich. Der Radius liegt bei etwa 150m, die Sendeleistung ist gering
\subsubsection{MIMO: Massive Multiple Input Multiple Output}
Mehrantennensystem, das die zeitliche und räumliche Dimension nutzt.\\
Durch Space-Time-Coding wird die Zuverlässigkeit und Daterate gestigert (redundante Datenpakete)
\subsubsection{Versteigerung}
Man erhöht den Kaufpreis und spekuliert auf das Ausscheiden eines weiteren Anbieters. Falls der Anbieter spät ausscheidet, ist die investierte Summe im Endeffekt um ein vielfaches höher
\subsection{Betrachtete Netze}
die hier betrachteten Netze agieren anders, als z.B. 5G
\begin{itemize}
	\item Kommunikation geschieht nicht über Handy Netz
	\item Die Netzstruktur ist dezentral und selbst-organisiert
	\item hohe Energieeffizienz enorm wichtig für Sensorknoten -> Lange Lebenszeit
	\item Alles für die wissenschaftliche Messung / Überwachung
\end{itemize}
\newpage
\section{Anwendungen}
Viele durch Sensornetze erreichte Optimierungen für das alltägliche Leben denkbar:
\begin{itemize}
	\item Neues Wissen ermöglichen
	\item Sicherheit erweitern
	\item Ressourcenmanagement
	\item Prävention von Fehlverhalten usw.
	\item[]
\end{itemize}

\par In folgende Kategorien kann unterteilt werden
\begin{itemize}
	\item Wissenschaftliches Instrument (``Macroscope'')
	\begin{itemize}
		\item Tiere, Pflanzen, Umweltphänomene
	\end{itemize}
	
	\item Industrielle Anwendungen
	\begin{itemize}
		\item Infrastruktureinrichtungen (Pipelines, Maschinen)
		\item Energiemanagement
	\end{itemize}
	
	\item Landwirtschaft
	\begin{itemize}
		\item Pflanzen (Wachstum, Reife, Bodenqualität)
		\item Tiere (Krankheiten, Fruchtbarkeit, virtuelle Zäune)	
	\end{itemize}
	
	\item Gesundheitswesen (``Body Sensor Networks'')
	\begin{itemize}
		\item drahtlose Intensivstation
		\item Verhaltensauffälligkeiten alter Menschen
		\item Lifestyle	
	\end{itemize}
	
	\item Militär / Polizei
	\begin{itemize}
		\item Erkennung, Klassifizierung, Lokalisierung des ``Bösen''	
	\end{itemize}
\end{itemize}

\subsection{Mikroklima}
Betrachtet wurden Redwoodbäume an der Küste Kaliforniens. Zur Motivation zählte die starke Variation und Dynamik klimatischer Bedingungen im Baum; kleine Wetterfronten bewegen sich entlang des Stamms. 
\subsubsection{System Überblick}
\textbf{Aufbau}
\begin{itemize}
	\item Sampling alle 5min
	\item 40-50 Knoten pro Baum
	\item Multi Hop Netz
	\item Messung von Temperatur, Feuchte, Sonneneinstrahlung
\end{itemize}
\textbf{Knoten:} Mote\\
\textbf{Netz:} TinyDB Sensor Netzwerk, Verbund über TASK Gateway, Funk über GPRS Modem\\

\subsubsection{Fazit}
\textbf{Beobachtung:} Trotz geringer Datenrate gab es einen hohen Datenverlust: 60\%  oder mehr\\

Ergebnis waren Zeitreihen pro Knoten, die gesamte Lebensdauer betrug 1,5 Monate. Pro Baum wurden 50 Knoten verwendet. Das Netz war \textbf{multihop}, \textbf{homogen} und \textbf{statisch}

\subsection{Brutverhalten}
Man möchte ein Modell für Brutpräferenzen des Wellenläufers erstellen. Dabei betrachtet man
\begin{itemize}
	\item Nestbelegung
	\item Klimatische Bedingungen in Höhlen
	\item Umweltbedingungen
\end{itemize}	
Die Beobachtung \textbf{muss} dezent erfolgen, da eine Abschreckung der Vögel blöd wäre.
\subsubsection{Architektur}
\begin{itemize}
	\item Mehrere verbundene Sensor Knoten bilden ein Sensor Patch
	\item Über Gateway sind diese mit einem Transit Netzwerk verbunden
	\item über Basestation mit dem Internet, worüber dann abgelesen werden kann
	\item \textbf{Wetter-}(Feuchte, Sonne, Druck) und \textbf{Nestsensoren}(Feuchte, Temperatur, Näherung) 
\end{itemize}
\subsubsection{Fazit}
	Die Infrastruktur für Kalibrierung war sehr komplex. Zudem gab es Schäden durch fehlerhafte Verpackungen, da Batterien ausliefen und den Knoten korrodierten.
	\textbf{Datenrate} und \textbf{Ergebnis} waren ähnlich wie oben erwähnt, das Netz war diesmal jedoch \textbf{heterogen}(Wetter und Nest + Gateways).
	\par Große Herausforderung war die \textbf{Kalibrierung }und \textbf{Verpackung}.

\subsection{Cane Toad Überwachung}
Kröten wurden nach Australien importiert, um Schädlinge beim Zuckerrohranbau zu regulieren. Ohne Feinde führte das zu einer starken Ausbreitung. Ein weit verstreutes \textbf{Sensornetz} zur Überwachung der Ausbreitung war gewünscht.
\begin{itemize}
	\item Die Erkennung der Kröten geschah anhand der Quak-Laute: Dauer, Häufigkeit, Frequenz...
	\item Das akustische Signal wurde aufgezeichnet, mit Forward Fourier Transformation umgewandelt. Daraus bestimmte man dominante Frequenzanteile, die mit C4.5 Algorithmus (\textbf{Entscheidungsbaum}) klassifiziert worden sind
\end{itemize}
\textbf{Herausforderung:} Akustische Aufnahme mit 10KHz, hohe Ressourcenanforderungen durch \textbf{Signalverarbeitung } und \textbf{Maschinelles Lernen}
\subsubsection{Architektur}
	Zweischichtiges Netz aus \textbf{Motes} und \textbf{Stargates}:
	\begin{itemize}
		\item Motes nehmen akustische Signale auf, führen Kompression durch (auf ca. 30\%), und schicken sie an Stargate per \textbf{Round-Robin-Schedule}
		\item Stargate klassifiziert auf den Signalen, \textbf{Voting Process} entscheidet darüber, ob weiter zum Server durchgelassen wird 
	\end{itemize}
\subsubsection{Fazit}
Separat lag die Korrektheit bei 100\%, bei 6 Kröten gleichzeitig lag die Implementierung 50\% richtig($\approxeq$Münzwurf). Latenz betrug 45sec, bei Kröten aber verkraftbar.

\subsection{Vulkane}
Es sollen die vulkanische Aktivität beobachtet werden. Ein Sensornetz soll als Ersatz für bisherige Messstationen in unerschlossenen Gebieten dienen. Messung von:
\begin{itemize}
	\item Seiesmischen Schwingungen breiten sich über Boden aus (am Fuß)
	\item Infraschall ($<$50 Hz) breitet sich über Luft aus (am Schlot) $\implies$ früher!
\end{itemize}	
\subsubsection{Architektur}
Früher: Große Box, viele Kabel, zentrale Stromverteilung, Single Point of Failure
	\begin{itemize}
		\item Microphone Motes zum EmpfängerMote verbunden (Freewave Modem)
		\item Knoten samplen und schicken kontinuierlich
		\item Modem schickt Signale an das 9km entfernte Observatorium
	\end{itemize}	

\subsubsection{Fazit}
	Infraschall ist guter Indikator für Eruptionen.\\
	Im Vergleich war die neue Architektur ähnlich gut wie die alte. Es gab eine mittlere Datenrate, Ergebnis waren \textbf{Zeitreihen} und \textbf{Ereigniserkennung}. Eine Sterntopologie lag vor, heterogenes Netz.
	
\subsection{Gletscher}
Man will ein besseres Verständnis der Dynamik im Gletscherinneren und Untergrund erlangen. Es soll en \textbf{Bewegungsmodell} für Gletscher entwickelt werden, und die \textbf{Auswirkungen der globalen Erwärmung} analysiert werden.
\subsubsection{Architektur}
\textbf{Bisher:} Bohren und Proben mit Bohrloch-Kameras\\
\textbf{Jetzt:} Knoten auf verschiedenen Tiefen des Gletschers. Diese senden an eine auf dem Gletscher befindliche Basistation (auf Batterie und Solar), die das Signal dann an die Referenzstation liefert.\\
\textbf{Proben}
\begin{itemize}
	\item PIC Mikrokontroller mit PLastikmanter
	\item Funkmodul für niedrige Frequenzen
	\item weitere Sensoren (Orientierung, Druck, Temp)
	\item Referenzstation war Linux Server
\end{itemize}
\subsubsection{Fazit}
Resultate waren Zeitreihen pro Knoten und deren Positionen (Verschiebung des Gletschers). Das Netz hatte eine Sterntopologie, war \textbf{heterogen} und \textbf{mobil}.

\subsection{Lokalisierung von Schüssen}
Ein Sensornetz zur Lokalisirung von Heckenschützen, Banden- und Straßenkriminalität. Erkannt werden sollte die Druckwelle der Gewehrmündung.\\
Sensorknoten war MICA2, Berkeley Mode, erweitert um \textbf{Mikrofon }und \textbf{Verstärker}.\\

\textbf{Teilaufgaben}
\begin{itemize}
	\item Erkennung der Druckwelle
	\item Zeitsynchronisation und Lokalisierung
	\item Senden an Basisstation, von wo aus die Abschussposition bestimmt wird
\end{itemize}
Signal wird kodiert. Ob das Muster passt wird anhand eines Zustandsautomaten bestimmt, Zuverlässigkeit 90\%.
\subsubsection{Positionsbestimmung}
Bei Schuss gibt es Nachrichten von vielen Knoten: Position $p_i$, Zeit $t_i$. Es gibt aber auch Fehlinformation durch Echos, falsche Erkennung etc. \\
Herangehensweise war eine a priori gesetzte Einschränkung des Suchraumes.\\
\textbf{Konsistenzfunktion:} Maß der Übereinstimmung der Hypothese $(p,t)$ mit tatsächlich gemessenen Werten
$$C_\tau (p,t) = \textsc{count}_i(|t_i(p,t)-t_i|\leq \tau)$$
Die \textbf{Suche des Maximums} erfolgte durch eine \textbf{Bisektion} des Lösungsraumes.
\subsubsection{Fazit}
Mittlerer 2D Fehler lag bei 0,57m, 3D Fehler bei 0,98m.\\
Die Datenrate war hoch, als Resultat hatte man eine Lokalisierung. Das Netz war \textbf{homogen} und \textbf{multi-hop}. Zeitsynchronisation von vielen Nodes und fehlerbehaftete Messdaten waren eine Herausforderung.

\subsection{Funktionalität und Herausforderung}
Zur Funktionalität zählen:
\begin{itemize}
	\item kontinuierliche Datenströme (kein failure)
	\item Erkennung von Ereignissen
	\item Klassifizierung von Ereignissen
	\item Lokalisierung
\end{itemize}
Als Herausforderung gelten:
\begin{itemize}
	\item Energieeffizienz
	\item beschränkte Ressourcen
	\item Robustheit und Zuverlässigkeit
	\item Autonomie, Kosten, Kalibrierung, Skalierbarkeit
\end{itemize}
\newpage
\section{Hardware}
\subsection{Motes}
Entwickelt an der UC Berkeley in verschiedenen Ausführungen.\\
Vorhanden waren:
\begin{itemize}
	\item CPU, RAM (1-10KHz)
	\item Kommunikation mit bis zu 500kbps, 10-1000m
	\item Energieversorgung durch Batterie oder Energy Harvesting
\end{itemize}
In der Regel gibt es viele Varianten für jede Komponente. Wichtige Kriterien sind jedoch \textbf{Lebensdauer}, \textbf{Leistungsfähigkeit}, \textbf{Robustheit}, \textbf{Größe}, \textbf{Kosten}. Dies alles hängt natürlich von der Applikation ab.\\

\subsection{Prozessor}
Für Prozessoren gibt es verschieden Alternativen, wie 
\begin{itemize}
	\item Mikrocontroller, I/O Kanäle, Wandler...
	\item DSP für Signalverarbeitung
	\item FPGA mit frei programmierbaren logischen Gattern
	\item ASIC als applikationsspezifischer Chip
\end{itemize}
\subsection{Kommunikation}
Generell kann über \textbf{Funk}, \textbf{Licht}, und \textbf{Schall }kommuniziert werden. Wichtig ist die Betrachtung der Eigenschaften:
\begin{itemize}
	\item welcher Frequenzbereich? Breitband? Mehrere Kanäle?
	\item Reichweite? Interface? Datenrate?
	\item Energieverbrauch zum Senden und Lauschen
\end{itemize}
RFM TR1000 guter Listener, Chipcon CC2420 guter Sender
\subsection{Sensoren}
Es gibt passive und aktive Sensoren. Aktive Sensoren (Radar, Laser) messen immer \textbf{gerichtet}, während passive Sensoren sowohl gerichtet (Licht, Kamera) als auch \textbf{omnidirektional} (Temperatur, Feuchtigkeit) sein können.\\
Des weiteren wird in \textbf{analoge }(Spannung) und \textbf{digitale }Sensoren unterschieden.\\
\textbf{Beispiele:}\\
 \textbf{Beschleunigungssensor }(Gyro). Messung der Auslenkung erfolgt piezoelektrisch und kapazitiv.\\
 \textbf{Kohlendioxid} Änderung der Leitfähigkeit durch Freisetzung von Ionen
\subsection{Energieversorgung}
Hierzu zählen Batterien, Akkumulatoren, Gold-/Supercaps: Kondensatoren mit hoher Kapazität. Anforderung ist dabei eine geringe \textbf{Selbstentladung}, \textbf{Wiederverwendbarkeit }und \textbf{Spannungsstabilität}
\subsubsection{Energiegewinnung}
Elektrische Energie kann durch Umwandlung anderer Energieformen gewonnen werden.\\
\textbf{Beispiele:}
\begin{itemize}
	\item Brennstoffzellen (10-100 mW)
	\item Solarzellen (10 $\mu$W-15mW)
	\item Vibrationen (0.1-10.000 $\mu$W)
	\item Druck (piezo) (330 $\mu$W) 
	\item Radioaktiver Zerfall (150W / g)
\end{itemize} 
\textbf{Voraussage:} Energiedichte wird sich erhöhen, während Kostenreduktion langsam stagniert.
\subsubsection{Energieverbrauch}
Es gibt einen Trade-Off zwischen \textbf{Rechnen} und \textbf{Kommunizieren}. 1.000 Recheninstruktion sind in erwa äquivalent zu 1 Byte senden! Es ist also besser, lokal zu Rechnen statt zu kommunizieren. Dennoch: Ein Prozessor hält mit Akku etwa 12 Tage, Flash etwa 3, das ist nicht lange!\\
Als Lösung wird \textbf{Duty-Cycling} vorgeschlagen. Dahinter stehen \textbf{lange Schlafphasen}, währen der alle Komponenten ausgeschaltet werden. Voraussetzung ist außerdem \textbf{schnelles Aufwachen} und \textbf{kurze Wachphasen}. Damit wird die Lebenszeit auf 100Tage verlängert!\\
\begin{itemize}
	\item Zeit zum Aufwachen betrug dabei in etwa 1-10ms
	\item Beispiel: Telos T-Mote, ZigBee kompatibel, Erweiterungsstecker
\end{itemize}

\subsection{Miniaturisierung}
Vision ``SmartDust'': Sensorknoten im Format eines Staubkorns. Man hat sich für ein 3D Layout entschieden (lieber hochbauen, statt großflächig planar) mit stapelbaren und flexiblen Platinen. Man wünschte sich ein \textbf{System-on-Chip}, alle Funktionen in einem Halbleiterchip.\\
\textbf{Problem:} WiseNet SoC. Energieverbrauch skaliert nicht! Das Funkmodul hat eine relativ hohe Sendeleistung.\\
Alternativen zum Funk waren Laser:
\begin{itemize}
	\item große Distanzen überwindbar
	\item optische Empfänger sehr einfach und sehr klein
	\item durch Spiegel (Corner-Cube-Retroflector) im Dust wurde passive Laserkommunikation ermöglicht
	\item Smart Dust hatte aktive und passive Transmitter, Batterie am größten!
\end{itemize}
Die Basistation hat dann durch einen \textbf{defokussierten Laser} (Raster Scanning) Daten gesendet. Empfangen wurden diese durch eine Kamera mit \textbf{hoher Bildrate}. Empfang \textbf{mehrere Knoten gleichzeitig} war möglich (Knoten per Pixel)\\
\\

$\implies$ Braucht man das alles?\\

Was bringt die Zukunft? Wird das Moore'sche Gesetz so weiterlaufen?\\
Effiziente Funkmodule und neue Energiequellen in Entwicklung!
\newpage
\section{Betriebssysteme}
Was ist ein Betriebssystem? Es ist eine Abstraktion des Systems, welches Zugriff auf Systemressourcen vereinfacht. Zur Ressourcenverwaltung gehören \textbf{Speicher}, \textbf{Prozessor}, \textbf{Kommunikation} und \textbf{Ein-/Ausgabe}.\\

Das besondere an Sensornetzen ist, dass nur \textbf{wenige Ressourcen} bereitstehen, der \textbf{Prozessor primitiv} ist und jeder Node ein \textbf{spezielles Anwendungsprofil} hat.
\subsection{Nebenläufigkeit}
Unter Nebenläufigkeit versteht man die quasiparallele Ausführung mehrerer Aktivitäten. Zum Beispiel Lesen und Empfangen.\\
Jedes BS hat Prozesse und Threads (Prozesse ohne Adressraum). Probleme sind meist der \textbf{konfliktbehaftete Speicherzugriff} und der \textbf{Overhead für Prozesswechsel}.\\
Nebenläufigkeit realisiert durch:
\begin{itemize}
	\item \textsc{While}-Loop
	\item Events: asynchrone Ereignisse, Run to completion, auch mehrstufig denkbar
	\item Zustandsmaschinen
\end{itemize}
\subsubsection{Speicherverwaltung}
Der Speicher soll unter den Prozessen effizient aufgeteilt werden. Hierbei ist auf Schutz des Speichers zu achten!  (\textbf{MUTEX, SEMAPHORE}).\\
 Bei drahtlosen Sensornetzen gibt es keine virtuelle Speicherverwaltung, und damit auch kein Schutz! Dies ist jedoch nicht so tragisch, da eigentlich nur ein Prozess ausgeführt wird.\\
 Speicher ist aufgeteilt in \textbf{Reserviert |   Global   |     Frei   | Stack}\\
 Ein WSN hat keine Festplatten oder Flash, oder ROM, sondern nur einen \textbf{Flashspeicher}, typischerweise Random Access
 \subsection{Kommunikation}
 Wichtig für WSN ist der Austausch von Nachrichten zwischen Knoten. Dabei möchte man den Overhead minimal halten, und das Kommunikationsmodell ist \textbf{Hop-by-Hop}. Es ist lieber, \textbf{effizient} zu sein, als zuverlässig.\\
 
 Das Kommunikationsmedium in WSN ist meist Funk. Medienzugriff erfolgt über \textbf{MAC}, siehe unbedingt \textbf{CSMA/CA}. Das Routing ist oft Baum-basiert (Senke an alle, Knoten an Senke). Die Verwaltung der Nachbarschaft ist schwer, da nicht klar ist, wer der Nachbarknoten ist. Meist wird nach Verbindungsqualität gewertet.\\
 
 Sonstige Funktionen sind \textbf{Hardware-Treiber} (Sensoren, Uhr, I/O), \textbf{Energiemanagement} (Sparmodi, DutyCycling), \textbf{Programmierung ``over the air''}, \textbf{Komponenten}system (Ersatz für fehlende Prozesse)
 
\subsection{TinyOS}
Populäres Betriebssystem der Berkeley Motes:
\begin{itemize}
	\item Komponenten System
	\item Events + Scheduler
	\item Active Messages (``Remote Events'')
\end{itemize}
\begin{center}
\includegraphics[height = 4cm]{TinyOS.png}
\end{center}
Besteht aus \textbf{Commands} (=Methoden), \textbf{Events} (Ereignisse), \textbf{Event-Handler} (kurze Funktion die beim Event abgearbetet wird), und \textbf{Task} (längere, asynchrone Funktion)
\begin{itemize}
	\item \textbf{Methode:} Aufruf \textsc{call}
	\item \textbf{Event:} (HW) Interrupt: \textsc{signal}
	\item \textbf{Tasks:} können alles
	\item \textbf{Scheduler:} FIFO
	\item Split-Phase-Operation: Event/command postet Task; wenn beendet, signalisiere Event
\end{itemize}
Zu den Komponenten gehören \textbf{Interface}, \textbf{Modul} (=Klasse), und \textbf{Configuration} (Komposition von Modulen, Anwendung). Darüber hinaus gibt es die Möglichkeit, Event-Handler aus der Ferne zu aktivieren (durch \textbf{Active Messages}). Eine AM enthält dabei die ID des Handlers und die Nutzdaten.
\subsection{Events: Freund oder Feind?}
Threads sind in der Regel bequem, aber oft ineffizient.\\
Events dagegen sind effizienter als Threads, aber oft umständlich.\\

Die Problematik bei Events ist, dass die Funktion aufgespalten werden muss. Dies führt zu
\begin{enumerate}
	\item globalen Variablen
	\item expliziten Zuständen
\end{enumerate}
\textbf{Verkettung} ist durch Aufruf des Events im Event möglich.
\subsection{OSM, andere}
\newpage
\section{Vernetzung von Sensoren}
Es stellt sich die Frage, wie man einen Sensorknoten zum Netz verbindet.
\begin{itemize}
	\item \textbf{1-Hop:} Jeder Knoten kann mit jedem. Ausdehnung durch \textbf{Kommunikationsreichweite beschränkt}
	\item \textbf{Stern:} Alle Knoten mit leistungsfähiger Basisstation (zB SmartDust)
	\item \textbf{Cluster:} Sensorknoten kommunizieren \textbf{NUR} mit leistungsfähigem Head, Heads kommunizieren untereinander
	\item \textbf{Multi-Hop, Ad-Hoc:} Knoten kommunizieren mit Nachbarn, und nehmen andere als Knoten Router
\end{itemize}
Jeder Knoten kann zudem eine gewisse Knotenrolle annehmen. Zur Auswahl stehen dabei \textbf{Datenquellen} (Sensor), \textbf{Aggregatoren} (empfangen von mehreren Knoten, Reduktion), \textbf{Router} (leiten weiter) und \textbf{Senken} (Datenbank). Die Zuweisung ist dabei oft natürlich und hängt von der Netzstruktur ab.
\subsection{Senken}
Es sind Sammelstellen für Daten. Diese Stellen jedoch \textbf{Engpässe} dar, da Knoten in der Nähe der Senke viele Daten weiterleiten müssen (zB. EG Auswahl im Fahrstuhl).\\
Als Lösungsmöglichkeiten könnte man die Verwendung mehrerer Senken vorschlagen, oder eine erhöhte \textbf{Aggregation} der Daten im Netz.
\subsubsection{Sensor Internet}
Senken Könnten auch Gateways zum Internet bilden. Dadurch erhält man ein \textbf{globales} Sensornetz! \\
Hierfür sind aber weitere Schritte notwendig. Die Internet- und Web-Integration stellt eine große Herausforderung dar:
\begin{itemize}
	\item IP im Sensornetz? Oder soll das Protokoll übersetzt werden?
	\item IP-Adresse pro Knoten oder pro Netz?
	\item Wie repräsentiert man es als Web-Service?
\end{itemize}
\subsubsection{Sensor-Aktor-Netze} 
Bei Robotern oder Lampen gibt es neben Sensorknoten zusätzlich noch einen \textbf{Aktorknoten}. Diese werden mittels aus Sensordaten gewonnenen Informationen gesteuert. Hierbei gibt es \textbf{keine} Senken.\\

Im allgemeinen unterscheiden sich Netze aus Sensorknoten gerade dadurch. Bei Sensornetzen stehen die \textbf{Messdaten} im Vordergrund, nicht die Knoten. Die \textbf{Verarbeitung} der Daten geschieht im Netz, nicht an jedem Knoten selbst. Welcher Knoten Daten liefert ist grundsätzlich egal, da jeder Knoten identisch ist. Hierdurch wird die \textbf{Datenbasierte Adressierung} eingeführt: Man spricht mit allen Knoten, auf die eine Eigenschaft/Event zutrifft, nicht deren Adresse.\\

In WSN werden zudem die Protokollstacks verschmolzen. Dies wird als Hilfsmittel zur Optimierung von Energie- und Ressourcenverbrauch genutzt. Ein \textbf{gezielter Austausch} von Informationen wird somit ermöglicht.

\newpage
\section{Modulations Techniken}
Unter Modulation versteht man die Modifizierung eines Signals in eine Form, die es möglich macht, dieses Signal zu verschicken. Wird vor allem für langwellige Signale genutzt. Dabei wird das Signal mit einem \textbf{sinusförmigen Carrier Signal} verbunden
\subsection{Analoge Modulation}
\subsubsection{Amplitude Modulation}
Simpelste Art der Modulation, sehr simpel und kosteneffektiv, jedoch anfällig für Störungen.
$$S_{AM}(t)=[A_c+S_m(t)]\cdot\cos(W_c t)$$ 
\subsubsection{Frequenz Modulation}
Frequenz wird moduliert. Schaltung komplexer, aber weniger anfällig.
$$S_{FM}(t)=A_c\cdot\cos([W_c t + S_m(t)]t)$$
\subsubsection{Phasen Modulation}
Phase wird bei übertritt der x-Achse umgeswitcht.
$$S_{PM}(t)=A_c\cdot\cos(W_c t + S_m(t))$$
\subsection{Digitale Modulation}
Bei der digitalen Modulation ist der input eine binäre Sequenz, die mit einem sinusoiden Carrier moduliert wird. Dies ist robuster, einfacher zu multiplexen, und sicherer.
\subsubsection{Amplitude Shift Key}
Eigentlich simples ON-OFF Signal.
\subsubsection{Frequency Shift Key}
Es gibt 2 vordefinierte Frequenzen für Bit 1 und Bit 0.
\subsubsection{Phase Shift Key}
Phase des Cariiers wird instantan geshifted. 
\subsubsection{Quadrature Amplitude Modulation}
\subsection{Fazit}
PSK ist besser, da mehr Energieffizienz und weniger Fehleranfälligkeit. Höherlevelige PSK können die datenrate noch mehr erhöhen.
\newpage
\section{Bitübertragung und Sicherung}
Bitübertragung stellt die unterste Schicht des \textbf{ISO/OSI Modells} dar. In WSN geschieht die drahtlose Kommunikation meist über Funk: Die Bits werden über Funkwellen übertragen. Es ist wichtig, einige grundlegende Aspekte zu betrachten um sein Verständnis zum Thema Medienzugriff zu festigen.\\
\subsection{Frequenzbereiche}
Es gibt unterschiedliche Frequenzbereiche mit unterschiedlichen Eigenschaften, wie \textbf{Durchdringung und Dämpfung}, \textbf{Reflektion}, \textbf{Energieaufwand} etc.\\
\begin{itemize}
	\item $<30$kHz: VLF
	\item $<300$MHz: Koaxial-Kabel
	\item $300$MHz bis $6G$Hz: Unser Funk Kommunikationsspektrum
	\item $>300$THz: Licht
	\item$\implies$ Je größer die Frequenz desto geringer die Reichweite/stärker die Dämpfung
\end{itemize}
Die Frequenzbereiche sind bestimmten Anwendungen zugeordnet, wobei die Verwendung üblicherweise lizensiert ist. Für WSN sind die \textbf{lizenzfreien ISM} Bereiche interessant (Industrial, Scientific,  Medical).
\subsection{Modulation}
Modulation ist die Art, wie Bits übertragen werden. Die Übertragung geschiet meist mittels \textbf{sinusförmiger EM-Wellen}, welche auf deren Parameter untersucht wird:
\begin{itemize}
	\item Amplitude
	\item Phase
	\item Frequenz
\end{itemize}
Man unterscheidet dabei in drei Arten des Keying (Auswahl der Modulation aus einem bestimmten Alphabet):\\

\textbf{Amplitude Shift Keying:} Die Amplitude variiert je nach Bit\\
\textbf{Frequency Shift Keying:} Die Frequenz variiert (1 Hoch, 0 Tief)\\
\textbf{Phase Shift Keying:} Die Phase ändert sich bei Flanken\\

Als Demodulation bezeichnet man nun die Rekonstruktion der übertragenen Informationen aus der empfangenen EM-Welle. Hierbei wird die EM-Welle im Empfänger \textbf{abgetastet}.
\subsubsection{Probleme}
Meist ist die empfangene Welle nicht gleich der gesendeten Welle. Die Welle wird nämlich durch
\begin{itemize}
	\item Dämpfung
	\item Reflektion
	\item Brechung etc
\end{itemize}
verzerrt. Dadurch ist zwar eine Kommunikation ohne Sichtverbindung möglich, aber mehrere \textbf{reflektierte Pfade interferieren}, und \textbf{Echos} lassen sich schwer filtern.\\

Zudem ist die \textbf{Synchronisation} schwierig, da festgehalten werden muss, wann ein \textbf{Bit}, \textbf{Byte} oder \textbf{Packet} beginnt.\\

Die empfangene Signalstärke lässt sich grob abschätzen durch eine Funktion des Funkkanals und des Abstandes $d$ zwischen Sender $s$ und Empfänger $r$
$$P_r = P_s \cdot K \cdot \frac{1}{d^n}$$
$n$ ist dabei in freien Räumen klein, und Gebäuden zwischen 2 und 6.\\

Weiter Störungen stellen (weißes) Rauschen dar. Außerdem sind Interferenzen möglich, wenn andere Sender im gleichen Frequenzbereich sind. Die \textbf{Signal-to-Interference-Noise-Ratio}:
$$\textsc{SINR} = \dfrac{P_r}{P_{\textsc{noise}} + P_{\textsc{inf}}}$$
Aus \textbf{SINR} und Art der Modulation resultiert die \textbf{Bitfehlerrate (BER)}.
\begin{center}
	\includegraphics[height = 6cm]{BER-PSK.png}
\end{center}
\subsubsection{Synchronisation}
Synchronisation wird durch \textbf{Präambeln} realisiert. Präambeln sind ein spezieller Bitstrom vor jeder Nachricht, der oft sehr lang ist. Dieser erlaubt die Unterscheidung einer \textbf{Übertragung} von \textbf{Rauschen}.
	
\subsection{Sicherung}
Unter Sicherung versteht man die \textbf{fehlerfreie Übertragung von Bits} über einen fehlerbehafteten Kanal. Die Sicherungsschicht ist die zweite Schicht im ISO/OSI Modell.\\

Zur \textbf{Fehlerkontrolle} zählen Mechanismen, die fehlerhaft übertragene Bits \textbf{erkennen} und \textbf{korrigieren}. Hierbei unterscheidet man in zwei Varianten:
\begin{itemize}
	\item \textbf{Backward Error Control:} Ein Fehler wird erkannt und eine Neuübertragung wird veranlasst (kostenintensiv!)
	\item \textbf{Forward Error Control:} Redundante Kodierung des Signals, sodass Bitfehler ohne Neuübertragung erkannt und korrigiert werden können
\end{itemize}
\subsubsection{Backward Error Control}
Generell werden hier Bits in Blöcke aufgeteilt. Den Blöcken wird eine Prüfsumme hinzugefügt. Stimmen die Daten überein, schicht Empfänger ein \textbf{positive ACK}, ansonsten \textbf{negative ACK}. Beim Senden gibt es dabei die Varianten \textbf{Stop-And-Wait} (jedes Frame muss bestätigt werden) und \textbf{Sliding-Window} (Sequenz wird bestätigt). \\

Dieses Vorgehen erzeugt nur bei Neuübertragung Mehraufwand und ist bei geringer BER zu bevorzugen.
\subsubsection{Forward Error Control}
Dieses Vorgehen ist dagegen recht komplex. Hier werden Bits zu \textbf{Symbolen} zusammengefasst, und es gibt eine injektive Abbildung der Symbole auf Übertragungssymbole. Eine \textbf{korrekte} inverse Abbildung ist sogar bei Fehlern möglich, wenn die Azahl nicht überschritten wird.\\

Dieses Vorgehen erzeugt immer Aufwand, jedoch bei hoher BER zu favorisieren.

\subsection{Framing}
Unter Framing versteht man das Zusammenführen von Bits/Symbolen zu Paketen. Hierbei muss ein Tradeoff zwischen langen Paketen (evtl. mehr Bitfehler) und kurzen Paketen (hoher Aufwand für Header).
\begin{center}
	\includegraphics[height = 4.7cm]{Packetsize.png}
\end{center}
\subsection{Link Management}
Viele Protokolle gehen davon aus, dass ein Knoten seinen Nachbarn kennt. Ist bei WSN in der Regel jedoch \textbf{nicht} der Fall!\\
Ein Knoten kann als Nachbar vermutet werden, wenn:
\begin{itemize}
	\item SINR $\geq$ min
	\item BER, PER $\leq$ max
\end{itemize}
Die Qualität der Kommunikation zu den Nachbarn ist dabei \textbf{irregulär} und nicht zwangsweise proportional zum Abstand. Es ist über die Zeit variabel.\\

Für manche Anwendungen braucht ein Knoten das Wissen über die Position der Nachbarn. Dabei kann die Nachbarliste gemanaged werden durch eine adaptive Abschätzung der Linkqualität.
$$P_n = \alpha P_{n-1} + (1-\alpha)\frac{r_n}{r_n+f_n}$$
$r_n$: im Intervall empfangene Pakete\\
$f_n$: verlorene Pakete

\newpage
\section{Medienzugriff}
Knoten reden kreuz und quer - Wer bestimmt da den korrekten, konfliktlosen Zugriff von Ressourcen?\\

Medienzugriff (\textbf{MAC}, 2.Schicht ISO/OSI) regelt den Zugriff der Knoten auf ein gemeinsam genutztes Kommunikationsmedium. Dadurch sollen wechselseitige Störungen vermieden werden. Das Hauptziel ist die Reduktion des Energieverbrauchs, denn das Funkmodul ist primärer Energieverbraucher.	\\

Dies impliziert, dass möglichst viel geschlafen werden sollte, dafür aber taub.
\subsection{Probleme}
Die Energie wird oft einfach verschwendet, zum Beispiel bei \textbf{nutzlosem Lauschen}, \textbf{Kollisionen} von Nachrichten bei Überlagerung, \textbf{Mithören} von Nachrichtenm die man selbst nicht braucht, und \textbf{Protokoll-Overhead}.\\

\subsection{Kollisionen}
\textbf{Kollisionen} entstehen, wenn eine Empfänger mehrere Sender gleichzeitig hört. Dabei kann ein Sender die Kollision nicht erkennen, wenn er nicht im Empfangsbereich des anderen Senders ist.\\

Eine mögliche Lösung ist der \textbf{Capture-Effekt}, wo der Empfänger die Nachrichten des Senders verstärkt, wenn der Sender stärker ist. Alternativ kann man mehrere Synchronisierte Sender durch ein \textbf{logisches ODER} beim Empfänger abhören (gilt nur bei on-off-keying).\\

Um Energie zu sparen, muss man Abstriche bei anderen Eigenschaften machen. Hierzu zählen \textbf{Fairness}, \textbf{Durchsatz} und \textbf{Nachrichtenverzögerung}.

\subsection{Verkehrsaufkommen}
Weiteres Einsparpotenzial gibt es durch Beobachtung und Nutzung typischer Muster im Nachrichtenverkehr:
\begin{itemize}
	\item \textbf{Convergecast}: Alle Sensoren senden zur Senke
	\item \textbf{Broadcast}: Senke sendet an alle Knoten
	\item \textbf{lokale Interaktion}: Nachabrn tauschen Nachrichten untereinander aus
\end{itemize}
Auch die Art der Nachrichtengenerierung ist ein wichtiger Faktor. Man unterscheidet zwischen \textbf{gleichmäßigen Strömen} (regelmäßiges Auslesen) und \textbf{Burst} (Ereignis löst hohe Aktivität aus).
\subsection{MAC Einführung}
MAC Protokolle haben verfolgen zwei Ziele: Zum einen \textbf{Verdrängung} (Contention), wobei der Zugriff auf Medien wahlfrei ist und Kollisionen weitesgehend vermieden werden. Zum anderen \textbf{Zuteilung} (Schedule), wo ein Medium exklusiv zu den Knoten zugeteilt wird. Hierbei ist der Knoten nur während eines bestimmten \textbf{time slice aktiv} $\implies$ Zeitsynchronisation notwendig!
\subsection{Carrier Sense Multiple Access/Collision Avoidance}
Bei \textbf{CSMA} wird der Kanal abgehört. Wenn dieser frei ist, wird gesendet.\\
\textbf{CA} reguliert Kollisionen durch Kanalreservierung:
\begin{enumerate}
	\item Request to send: Anforderung mit geplanter Dauer $T$
	\item Clear to send: Bestätigung mit $T$
	\item DATA nach Empfang von CTS
	\item ACK nach Empfang von DATA
\end{enumerate}
Die Anzahl der \textbf{Kollisionen} steigt, je mehr Stationen auf das Übertragungsmedium Zugriff haben wollen. Durch lange Leitungen, sehr viele Stationen und Repeater (Signalaufbereiter und -verstärker) entstehen je nach Ort der Einspeisung unterschiedliche Signallaufzeiten. Sie führen dazu, dass eine Station ein freies Übertragungsmedium feststellt und ihr Signal sendet, obwohl das Signal einer anderen Station bereits unterwegs ist. Es kommt zur Kollision, also der Überlagerung von zwei Signalen.\\

\textbf{Verzögerung-Strategien} wie \textbf{Binary-Exponential-Backoff} (gleichverteilte Verzögerung aus festem Zeitfenster) klappen hierbei nur bedingt. Die Zeitfenster verdoppeln sich nach jeder erneuten Kollision, dies führt unter Umständen zu sehr langen Verzögerungen.\\

\textbf{Sift} ist eine Alternative zu BEB. Hierbei sind die Zeitfenster ebenfalls fest, aber die Wahl der Slots ist nicht gleichverteilt. Wenige Knoten wählen frühen Slot, wodurch die Kollisionswahrscheinlichkeit klein ist.\\

Will man nun in WSN CSMA/CA verwendet, so steht man vor einem Problem. Man möchte aus Gründen der Energieeffizienz für die Dauer $T$ das Radio ausschalten. Jedoch verpasst man dadurch andere \textbf{RTS}/\textbf{CTS}! Zudem muss der Protokeoll Overhead für jedes Datenpaket betrachtet werden, oder für mehrere Pakete (keine Fairness!).

\subsection{S-MAC}
\textbf{Sensor-MAC} funktioniert nach dem Rendevouz-Schema. Die Knoten verabreden quasi eine Zeit, in der sie miteinander arbeiten/kommunizieren. Es ist also eine \textbf{CSMA/CA mit Duty-Cycling}, die Knoten sind untereinander synchronisiert; auf kurze Aktivphasen folgt eine lange Schlafphase.\\

Synchronisierung bei S-MAC geschieht während der \textbf{SYNCH Phase}. Ein neuer Knoten lauscht dabei, und übernimmt das \textbf{Schedule}, ansonsten hält er sich an ein eigenes Schedule. Die \textbf{Latenz} bei Hops wird reduziert indem ein Knoten 3 nach \textbf{Lauschen des CTS} eine zusätzliche Aktivphase einführt und Knoten 2 \textbf{nach ACK direkt ein RTS} an 3 sendet.\\

$\implies$ Problem: Was wenn viele Nachbarn mit verschiedenen Schedules vorhanden sind?

\subsection{Timeout MAC}
Im Gegensatz zu S-MAC, wo die Aktivphase eine feste Länge hat, wird bei T-MAC die Aktivphase \textbf{an das Verkehrsaufkommen adaptiert}. Der Knoten wechselt frühzeitig in die Schlafphase, wenn eine gewisse Zeit $T_A$ nichts passiert.\\

\textbf{Early Sleeping:}Knoten geht zu früh in die Schlafphase, CTS blockiert Medium. Lösung: \textbf{FRTS}\\
\textbf{Volle Puffer:} Es kann vorkommen, dass man zum Empfangen gezwungen wird. Als Lösung wird vorgeschlagen, direkt ein RTS zu senden, statt mit CTS zu antworten. Jedoch erst, wenn der Puffer mehrmals überlief.\\

\textbf{Präambeln:} Diese werden zur Synchronisation benötigt. Wenn Knoten während der Aktivphase Präambel hört, bleibt er wach zum Datenaustausch. Jedoch sind Präambeln unnötig lang, wenn der Knoten schon wach ist. Stattdessen könnte man \textbf{mehrmals die Daten} schicken oder \textbf{Wakeup-Pakete}, die den Zeitpunkt der Datenübertragung enthalten.

\subsection{B-MAC}
Bei B-MAC wird das digitale Tonsignal in der Austastlücke eingespielt, also mit den Bildsignalen zeitgemultiplext. Da es nicht genügend Platz für eine geeignet große Anzahl an Tonkanälen bietet, wurde es hauptsächlich für Satelliten-Überspielungen zwischen Fernsehstationen verwendet sowie (verschlüsselt) für die Versorgung im Ausland stationierter Einheiten der US-Army mit Satellitenfernsehen. \\

B-MAC basiert auf einfachen Präambeln, die Philosophie ist: Minimum an Funktionalität mit einfacher Schnittstelle (TinyOS) $\implies$ maximale Flexibilität!

\subsection{IEEE 802.15.4 ``ZigBee''}
Bei ZigBee gibt es mehrere Knotenrollen:
\begin{itemize}
	\item PAN Coordinator
	\item Coordinator
	\item Device (Reduced Function Device)
\end{itemize}
Stern (Beacon-Mode) und Peer-to-Peer (Non-Beacon-Mode) Topologien möglich.
\subsubsection{Beacon Mode}
Coordinator und Device bilden sternförmiges Netz, wobei der Coordinator ständig Beacon sendet zwecks \textbf{Synchronisation} und \textbf{Zeitanteilung} im Frame.\\
Im \textbf{Active Period} werden Daten per CSMA übertragen (oder TDMA). Im \textbf{Inactive Period} wird geschlafen.

\newpage
\section{Routing}
Klassische Netze basieren typischerweise auf Adressen. Die verwendete Hauptkommunikationsform ist \textbf{Unicast} (1zu1 Kommunikation) oder \textbf{Multicast} (Nachricht an mehrere).\\

Bei Sensornetzen ist das etwas anders. Es wird vorwiegend \textbf{Convergecast} (alle senden Nachrichten an die Senke) und \textbf{Broadcast} (Senke sendet Nachricht an alle) verwendet.
Zudem gibt es auch lokale Interaktion zwischen zwei Knoten.\\

\textbf{Convergecast} ist die wichtigste Primitive. Es ist ein Spannbaum mit Senke an der Wurzel. Jedoch ist nicht klar, wie der TradeOff zwischen \textbf{Baumtiefe} und \textbf{Knotenentfernung} ist. \\

Es stellt sich also die Frage, wie man stabile Spannbäume erstellt bzw. auswählt. Die Prioriätatn wären dabei: 
\begin{enumerate}
	\item Link-Qualität
	\item Nachbar-Verwaltung
	\item Routen-Auswahl
\end{enumerate}

\subsection{Link-Qualität}
Man benötigt einen Mechanismus zur Abschätzung der Qualität der Verbindung zu einem Knoten.
Gemessen wird das anhand der \textbf{Paketverlustrate} \textbf{(PER)}
$$P_n = \alpha P_{n-1} + (1-\alpha) \underbrace{\dfrac{r_n}{r_n + f_n}}_{1-\text{PER}}$$
\textbf{Exponentially Weighted Moving Average}
$$P_n(t) = \alpha P_{n-1}(t) + (1-\alpha) (1-\text{PER})$$
\subsection{Nachbarverwaltung}
In WSN sind die Sensornetze dicht ($>200$ Nachbarn), viele Nachbarn haben dabei eine schlechte Link-Qualität, nur wenige sind gut. In der Regel wird eine \textbf{Nachbarschaftstabelle} verwaltet, aus der $T$ beste Nachbarn gefunden werden müssen.\\

Für die \textbf{Auswahl des $T$} gibt es verschiedene Herangehensweisen:
\begin{itemize}
	\item Xue and Kumar: $T>5.1774 \log n$: fast sicher verbunden
	\item Penrose: Wenn jeder $T$ Nachbarn hat, dann gibt es zwischen 2 Knoten wahrscheinlich T Pfade 
\end{itemize}
\subsection{Gute Nachbarn}
Jeder Knoten sendet ein ``Hallo''. Jeder Empfänger notiert sich Knoten, von denen die meisten ``Hallo'' empfangen worden sind. Ist er schon drin, wird er verstärkt. Ist die Tabelle voll, so wird per \textbf{LRU} oder \textbf{FIFO} ein alter Knoten gelöscht.\\

Dabei könnte man auch für jedes Inkrement ein Dekrement durchführen. Am Ende gibt es einen \textbf{einzigen Kandidaten}.\\

Am Ende sind die Nachbarn wahrscheinlich gut, aber durch \textbf{häufige Einfügeoperationen } ändern sich die Nachbarn oft, \textbf{nicht stabil!}.
Ein Einfügekriterium wäre, die Nachbarn mit Wahrscheinlichkeit $P=\frac{T}{N}$ einzufügen, wobei $N$ nun nicht bekannt ist...
\subsubsection{Nachbarn schätzen}
Man kann die Anzahl der Nachbarn mithilfe einer Hashfunktion schätzen... siehe:\\
``Probabilistic Counting Algorithms for Data Base Applications''

$\implies$ nun hat jeder noten eine stabile Menge an guten Nachbarn!

\subsection{Gute Links}
Ein guter Link ist ein Link mit \textbf{geringem Paketverlust}. Man vedient sich einer Routing-Metrik:
$$m(L)= \frac{1}{Q_{in}(L)} \cdot \frac{1}{Q_{out}(L)}$$
Dabei sind Links häufig asymmetrisch, die Knoten müssten also die Nachbarn über die Qualität derer Nachbarn aufklären.\\

\subsubsection{Guter Baum}
Guter Spannbaum bedeutet, dass es einen guten Pfad von jedem Knoten zur Senke gibt. Man möchte also den kürzesten Pfad gemäß Routing-Metrik finden:
$$\min \sum m(L)$$
Verfahren? \textbf{Distance Vector Routing:} Jeder Knoten merkt sich Abstand zur Senke und zu aktuellem Vater $V$. Beim \textbf{Update} schicken die Knoten ein Paket $P$ mit Abstand $D$ zur Senke an Nachbarn. Der Nachbar empfängt dann $P$ über Link $L$.\\
Falls $P.D + m(L) < D$:\\
$D := P.D+m(L)$\\
$V := S$\\
Update an Nachbarn sofort verschickt.\\

\textbf{Stabilität} (periodische Ausführung führt zu geringem Vaterwechsel), \textbf{Zyklen} (selbst gesendete Pakete erkennen) und \textbf{Fairness} (lokale Nachrichten haben Priorität vor anderen)
	
\subsection{Aggregation und Interaktion}
Theoretisch könnte jeder Knoten die Daten seiner Kinder aggregieren. Man muss jedoch berücksichtigen, welche Daten von Interesse sind, von welchem Knoten sie kommen, wie oft sie aggregiert werden etc.\\

\textbf{Fluten} mit beschränktem Hop-Radius gilt als eine Art der lokalen Interaktion. Dabei wird die Nachricht mit Hop-Radius $r$ verschickt, diese wird dann mit $r-1$ weitergeleitet usw.\\
Probleme beim Fluten wäre eine \textbf{Implosion} (identische Daten erreichen Knoten über mehrere Wege) oder eine \textbf{Überlappung} überlappende Sensorknoten hat selbe Daten mehrfach.\\

\textbf{FireCracker:} Die Nachricht entlang des Spannbaums verteilen und dann Fluten.\\

Andere Methoden:
\begin{itemize}
	\item Geo Routing (Schick an bestimmte Position)
	\item Face Routing (Polygone im Netz)
\end{itemize}

\newpage
\section{Zeitsynchronisation}
Zeitsynchronisation dient dem gemeinsamen Zeitverständnis. Alle Uhren zeigen die selbe Zeit, Knoten $A$ weiß also, wie spät es bei Knoten $B$ um 12 war. Nützlich für Interaktion mit \textbf{Nutzer}, \textbf{Koordination im Sensornetz} und die Interaktion des Netzes mit der \textbf{realen Welt}.
\begin{itemize}
	\item Nutzer: Wann soll was beobachtet werden? Wie lange dauert ein Vorgang?
	\item Reale Welt: konsistente verteilte Messungen, Fusion verteilter Beobachtungen
	\item Sensorknoten: drahtlose Kommunikation, Energieeffizienz, Lokalisierung
\end{itemize}
\subsection{Arten von Synchronisation}
\begin{itemize}
	\item \textbf{Intern/Extern:} Knoten einigen sich auf eine Zeit vs. Zeit wird von außen vorgegeben
	\item \textbf{Lebenszeit:} immer, oder dann, wenn benötigt? Energie!
	\item \textbf{Scope:} Welche Knoten? Alle oder Manche?
	\item \textbf{Rate/Offset:} Uhren laufen gleich schnell, es ist also die \textbf{Dauer} wichtig, oder die Uhren zeigen alle die \textbf{gleiche Zeit}
	\item \textbf{Skalen und Uhren:} Lokale Uhren auf gleicher Zeit oder Uhren mit unterschiedlichen skalen?
	\item \textbf{Zeitpunkte/Intervalle:} fehlerhafter Zeitpunkt oder korrektes Intervall?
\end{itemize}
Zu den Hindernissen zählen natürlich die Eigenschaften der Hardware Synchronisation und die Eigenschaften der drahtlosen Kommunikation. \textbf{Hardware Uhren} zählen Intervalle fester Länge, kann aber von HW zu HW abweichen! Eine Atomuhr ist zwar $10^5$ genauer, aber verbraucht $100$mW.\\

Bei der Kommunikation gibt es zudem Schwankungen durch \textbf{Interrupts}, \textbf{Zugriffe}, \textbf{Encoding}, \textbf{Decoding} etc.

\subsection{Synchronisation von Knoten}
Wenn Klinet R die Zeit $h_R$ anzeigt, was zeigt dann die Zeit von K $h_K$ an? Klient kann seine Zeit dann $h_R-h_K$ korrigieren.
\subsubsection{Unidirektional}
R sendet Nachricht, die $h_R$ enthält, der Klient nimmt dann $h_K := h$ an. Dies ist mit mehr Klienten per Broadcast Problemlos möglich.
\subsubsection{Round Trip}
$h_1$ an $h_R$, $h_R$ an $h_2$. $h_K$ nimmt dann die Zeit
$$h_K:=\frac{h_1 + h_2}{2}$$
Dies ist mit mehreren Knoten jedoch aufwändig!
\subsubsection{Referenz Broadcast}
Beacon sendet Broadcast an Referenz und Client. Danach kommunizieren die Knoten. Vergleichsweise genau, weil Broadcast nahezu Zeitgleich empfangen wird.
\subsubsection{Dauerhafte Synchronisation?}
Eine dauerhafte Synchronisation ist schwer umzusetzen. Dabei gibt es 2 Varianten:
\begin{itemize}
	\item periodisches Wiederholen: Die Genauigkeit hängt von der Synchronisierung ab. Stetigkeit ist ein Nachteil, verbunden mit hohem Energieaufwand
	\item Anpassung der Ganggeschwindigkeit: Man misst, wie viel $h_K$ schneller als $h_R$ läuft, passt dann die Geschwindigkeit an. Möglichkeit sind \textbf{Lineare Regression} oder \textbf{Phase-Locked Loops} (Steigung abhängig von der Messung ändern)
\end{itemize}
\subsection{Mehrere Klienten}
\subsubsection{Out-of-Band}
Klient hat eine Clique, und mindestens einen Referenzknoten als Nachbarn. Hierfür ist eine genaue Infrastruktur notwendig!
\subsubsection{Cluster}
Das Netz ist in Cluster strukturiert, und man hat Gateways, die die überlappenden Cluster verbinden. Wartung der Struktur ist aufwändig!\\
\textbf{BSP:} Reference Broadcast Synchronization
\subsubsection{Baum}
Referenz ist an der Wurzel, Kinder synchronisieren sich mit Vätern. Das führt zu langen Pfaden und größeren Ungenauigkeiten, und vergleichsweise ungenauen Pfaden\\
\textbf{Bsp:} \textbf{Time Sync Protocol for Sensor Networks}
\subsubsection{Unstrukturiert}
Kein Overlay - kein Aufwand! Knoten nutzen dann beliebige Pfade zur Synchronisation.\\
\textbf{Bsp:} Time Stamp Synchronization, die Zeitstempel werden entlang eines Pfades syncronisiert, Round Trip zwischen Nachbarknoten
	
\newpage
\section{Lokalisierung}
Man will die Koordinaten eines Knotens in einem (Euklidischen) Koordinatensystem bestimmen. Ziel ist eine genauere \textbf{Interpretation} der Sensordaten, \textbf{Daten-Fusion} etc. Hier sind die Unterscheidungen ähnlich der Zeitsynchronisation. \\

\textbf{GPS} für alle Sensorknoten ist aus Gründen der Energie nicht machbar, und Kosten im Vergleich zum Sensorknoten deutlich mehr. Und man braucht eine Sichtverbindung zum Satelliten.
\subsection{Lokalisierungs-Algorithmen}
In der Regel drei typische Phasen:
\begin{enumerate}
	\item \textbf{Relationen zwischen Knoten messen} 
	\item \textbf{Platzierung}
	\item \textbf{Verfeinerung}
\end{enumerate}
\subsection{Relationen zwischen Knoten}
Meist Abstand basiert, \textbf{Winkel im freien Feld} jedoch besser. Gemessen wird anhand von \textbf{Schall}, Indikatoren sind \textbf{Signallaufzeit} und Stärke. Das Signal ist speziell kodiert, der Empfänger sucht nach dem ersten Match (\textbf{Echos!}). Genauigkeit best case sind 1cm, Reichweite 10m\\

\textbf{ABER:} Schall hängt von \textbf{Temperatur} ab (Sensor rauf), \textbf{Orientierung} (spezielle Reflektoren) und \textbf{Hindernisse} (große Fehler durch Multi-Path)\\

Die empfangene Signalstärke lässt sich abschätzen:
$$P_r(d)\approx P_s \dfrac{1}{d^n}$$
oder \textbf{Received Signal Strength Indicator}
$$\textsc{RSSI} = 10 \log_{10} P_s - 10n\log_{10}d$$
Bestenfalls sind 2m-3m möglich.\\

Ausrichtung der Antennen zueinander und Höhe über Boden hat starken Einfluss (Reflektion/Dämpfung)! Indoor ist RSSI quasi \textbf{unkorreliert}!\\
\\
\textbf{Interferometrie} ist genauer, aber Funktionalität ist unklar!  
\subsection{Platzierung}
Die Position ist durch \textbf{Anker mit bekannter Position} und Relationen zwischen Knoten gegeben. Gesucht sind die Positionen von Nicht-Anker-Knoten.

\subsubsection{Zentroid}
Knoten liegt im Schwerpunkt aller Anker. 
$$x,y = \frac{1}{n} \sum_{i=1}^{n}x_i,y_i$$
\subsubsection{Bounding Box}
Platziere Knoten im Schnitt der Bounding Boxen um alle Anker.
$$x = \frac{1}{2}(\min _i(x_i+d_i) + \max _i(x_i-d_i))$$
\subsection{Multi-Hop}
Bisher hat jeder Knoten 3 Anker gebraucht, skaliert schlecht! Sehr viele Anker sind keine Lösung.\\
 
\textbf{Multi-Hop:} Jeder Anker flutet das Netz, in jeder Nachricht ist der kürzeste Abstand zum Anker vermerkt\\

\textbf{Rekursion:} Berechnete Positionen werden als weitere Anker betrachtet $\implies$ Fehler akkumuliert sich! 

\subsection{Verfeinerung}
Jeder Knoten bekommt eine Abschätzung seiner Position. Diese verbessert er \textbf{iterativ}, indem er alle seine Nachbar als Anker verwendet. So lange, bis keine signifikante Veränderung der Position mehr da ist.

\newpage
\section{Datensammlung und Verarbeitung}
\subsection{Sampling}
Sampling bedeutet Messung einer bestimmten Quantität $q(x,y,t)$ in regelmäßigen Abständen. Die Frage ist, wie groß man $f_t$ und $f_x$ wählt. Man möchte eine \textbf{Aliasing} verhindern, bei dem hohr Frequenzen wie tiefe Frequenzen erscheinen, weil die Sampling-Rate zu gering ist.\\

\textbf{Nyquist Kriterium}: $f_t$ doppelt so groß wie der höchste \textbf{zeitliche} Frequenzanteil, $f_x$ doppelt so groß wie der größte \textbf{räumliche} Frequenzanteil
\subsection{Resampling}
Die Verteilung der Sensoren ist typischerweise\textbf{ nicht uniform}. Dadurch \textbf{interpoliert} man stückweise das Signal, eine \textbf{Approximation}, mit der man zB Werte an Gitterpunkten bestimmt.
\subsection{Coverage}
Man möchte sicherstellen, dass eine hinreichende räumliche Sampling-Rate $f_x$ ausreichend ist. Oftmals hat man mehr Sensoren als notwendig, man schaltet also nur so viele wie nötig ein, und behält die restlichen als \textbf{Reserve}.\\

\textbf{k-Coverage:} Jeder Punkt ist im Sensorbereich von mindestens $k$ Knoten
\subsection{Kalibrierung}
Unterschieden wird in \textbf{absolute} Kalibrierung und \textbf{relative} Kalibrierung.
\subsection{Cleaning}
Unter Cleaning versteht man das Bereinigen roher Messwerte. Dazu gehören \textbf{``Outlier''}, \textbf{fehlende Messwerte}, und \textbf{Rauschen}. \\

Realisiert	 wird dies durch verschiedene \textbf{Filter}. 
\begin{itemize}
	\item Hochpassfilter (keine Tiefen, Betonung hoher Frequenzen)
	\item Tiefpassfilter (keine Hohen)
	\item Mittelwert Filter (Mittelwert in Nachbarschaft der Größe $N$)
	\item Median Filter (Sortieren und die Mitte nehmen)
	\item Konvolution
	\item Kantenerkennung (Sobel)
	\item EMWA: \ \  $s_{new}(t) = (1-\alpha)s_{new}(t-1) + \alpha s(t)$
\end{itemize}
\subsection{Kalman Filter}
\begin{center}
	\includegraphics[height = 5cm]{Kalman.png}
\end{center}
Man hat ein \textbf{Zustandsmodell} und ein \textbf{Messmodel}. Man verbinden die beiden Zustände zu einer besseren Abschätzung, je nachdem ob man der Messung oder der Odometrie mehr traut.\\

Kalman Filter kann mehrere Sensoren mit optimaler Gewichtung integrieren!

\subsection{Partikel Filter}
Die Verteilung ist beliebig, multimodal. Particle-Filter sind jedoch weniger effizient.
Die Idee ist, das eine Verteilung durch die Dichte der Partikel symbolisiert wird.

\subsection{Kompression und Prädiktive Filter}
Wenn $s(t)$ aus der Vergangenheit berechnet werden kann, dann wird $s(t)$ nicht effizient übertragen!\\

Man kann Filter wie bisher anwenden, jedoch deren Ausgabe als Vorhersage verwenden! \\

Mit \textbf{Least Mean Squares Adaptation} lässt sich der Kernel automatisch anpassen, wodurch die Vorhersage möglichst genau wird. Das funktioniert so gut, weil \textbf{zeitlich benachbarte Daten} sehr ähnlich sind.

\subsection{Tracking}
Unter Tracking versteht man das Verfolgen der Bewegung eines Objektes (\textbf{Position, Richtung, Geschwindigkeit}). Das Objekt taucht dabei auf, bewegt sich auf einem Pfad, und verschwindet dann wieder.\\

Objekte lassen sich mittels von ihnen emittierten Signale detektieren. Klassifikation erfolgt dann anhand eines \textbf{Spektrogramms}. Die Lokalisierung des Objekts ermittelt sich durch den Sensor mit dem höchsten Signal.\\

Die Detektion von mehreren Objekten ist jedoch schwierig! Objekte sind für Sensoren meist ununterscheidbar.

\section{Dezentrale Ansätze}
Man möchte ein dezentrales und impliziertes Synchronisieren von Phasen, wie bei Glühwürmchen, erreichen.\\

Das \textbf{Glühwürmchen-Modell} sieht dabei folgendermaßen aus:\\
Das Licht wird alle $L$ Sekunden angemacht. Wenn Mehrheit der Nachbarn bereits Licht an hat, dann soll die Uhr vorgestellt werden, ansonsten nichts tun. Alternativ vice versa.

\subsection{Kuramoto Modell}
Es handelt sich um gekoppelte Oszillatoren. Global gilt:
$$\dfrac{d \theta_i}{dt} = \omega_i+\dfrac{K}{N}\sum_{j=1}^{N}\sin(\theta_j-\theta_i)$$ 
Für eine Nachbarschaft $\mathcal{G}_i$ gilt dann lokal:
$$\dfrac{d \theta_i}{dt} = \omega_i+\dfrac{K}{|\mathcal{G}_i|}\sum_{j\in \mathcal{G}_i}\sin(\theta_j-\theta_i)$$ 
\subsection{Millenium Bridge}
Der Fußgänger auf der Brücke wird als ein Inverses Pendel beobachtet:
$$\ddot{\theta}-\dfrac{g}{l}\sin\theta = 0$$
\subsection{Van-der-Pol-System}
Ein Van-der-Pol System ist ein schwingungsfähiges System mit nichtlinearer Dämpfung und Selbsterregung.
$$\dfrac{d^2x}{dt^2}-\mu (1-x^2)\dfrac{dx}{dt}+x = 0$$
\begin{center}
	\includegraphics[height = 5cm]{VDP.png}
\end{center}

\subsection{Skalierbarkeit}
Man möchte untersuchen, wie vernetzte Systeme mit der Anzahl der Knoten skalieren. Es werden also dem Netz mehr und mehr Knoten hinzugefügt und geschaut, wie sich die Leistung des gesamten Netzes entwickelt.
\begin{itemize}
	\item Menschliche Teams: Ringelmann-Effekt
	\item Computer Server
\end{itemize}
Bei geteilten Ressourcen erzeugen \textbf{Zugriffskonflikte} lange Wartezeiten.
\subsubsection{Universal Scalability Law (USL)}
Systemkapazität $C(N)$
$$C(N) = \dfrac{N}{1+\alpha(N-1)+\beta N (N-1)}$$
$\alpha \ $ Grad an Zugangskonflikten, $\ \beta \ $ Mangel an Kohärenz.\\
\\
Man Unterscheidet in vier Bereiche
\begin{enumerate}
	\item equal bang for the buck
	\item Kosten durch Ressourcenteilung
	\item Vermehrte Zugangskonflikte
	\item negative Rendite
	\item ``inoffiziel'': Superlineare Skalierung
\end{enumerate}	
	Unter \textbf{Payback-Zone} versteht man die sublineare Skalierung nach einer superlinearen skalierung.
	
	
	
	
	
	
	
	
	
	
	
	
	
\end{document}